---
title: 'FiFi‘s School Work: Information Security Foundation'
date: 2022-05-15
permalink: /posts/2022/05/blog-post-InformationSecurityFoundation/
tags:
  - CS
  - Knowledge
---

重庆大学计算机学院 ｜ 22Spring ｜ 信息安全基础

## Chap1 信息安全基本概念

- 信息的概念

	- 对比
		- “信息”不同于消息：消息是表现形式，**信息是实质**
		- “信息”不同于情报：**情报含义比”信息”窄**，是一类特殊的信息
		- “信息不同于知识”：**知识是有价值的信息**，是一种高层次的信息

	- 香农：信息是用来消除随机不定性的东西
	- 信息熵：信息的不确定性度量

- 信息技术

	> 概念：能扩展人处理信息功能的技术

	- 类别：感知技术/ 通信技术/ 计算技术
	- 阶段：C1S11
	- 发展趋势：C1S12

- 信息安全

	- 概念
		- **从信息本身的角度**：保障信息不被未经授权使用（破坏）
		- **从信息技术的角度**：保障信息被正确地处理（创建、输入、存储、输出、传输、计算、销毁）
		- **从应用场景的角度**：计算机安全、网络安全、信息系统安全、网络空间安全等概 念，**本质上是在这些场景下确保信息和处理信息的安全**

	- 威胁分类

		- 实体安全
			- **作用点：**对计算机网络与计算机系统的物理装备的威胁，主要表现在自然灾害、电磁辐射与恶劣工作环境方面。
			- **外显行为：**通信干扰，危害信息注入，信号辐射，信号替换，恶劣操作环境。
			- **防范措施：**抗干扰系统，防辐射系统，隐身系统，加固系统，数据备份。
		- 网络安全
			- **作用点：**对计算机网络与计算机系统可用性与可控性进行攻击。
			- **外显行为：**网络被阻塞，黑客行为，非法使用资源等，计算机病毒，使得依赖于信息系统的管理或控制体系陷于瘫痪。
			- **防范措施：**防止入侵，检测入侵，攻击反应，系统恢复。
		- 系统安全
			- **作用点：**对各种系统的使用进行的攻击威胁，主要表现在操作系统、数据库、Web系统、电子商务等应用系统等的攻击威胁。
			- **外显行为：**冒充合法用户，篡改密码，信息抵赖。
			- **防范措施：**加密身份认证技术，系统加固技术，安全交易协议。
		- 数据安全（信息安全）
			- **作用点：**对所处理的信息机密性与完整性的威胁，主要体现在加解密、防篡改、数字产品产权等方面。
			- **外显行为：**窃取信息，篡改信息，冒充信息，信息抵赖。
			- **防范措施：**加解密，完整性技术，数字签名，数字水印。
		- 内容安全
			- **作用点：**有害信息的传播对我国的政治制度及传统文化的威胁，垃圾信息对人们日常生活的干扰。
			- **外显行为：**淫秽暴力信息泛滥、敌对的意识形态信息涌入、英语文化的“泛洪现象”对民族文化的冲击，垃圾信息泛滥。
			- **防范措施：**监测、控管、信息过滤、隐私保护，法律法规

	- 应用场景

		- 网络安全

		- 安全攻击

			- 被动攻击：试图了解或利用系统的信息但不影响系统资源 -> 窃听、检测：消息内容的泄露、流量分析

				<img src="https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_informationsecurity/1.png"/>

			- 主动攻击：试图改变系统资源或影响系统运作 -> 对数据流进行修改、伪造数据流

				- 伪装：指某实体假装别的实体
				- 重播：指将获得的消息再次发送以产生非授权的效果
				- 消息修改：指修改合法消息的一部分或延迟消息的传输或改变消息的顺序以获得非授权的效果
				- 拒绝服务：阻止或禁止对通信设施的正常使用或管理

				<img src="https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_informationsecurity/2.png"/>

		- 常见攻击：C1S27

- 多角度理解信息安全

	- CIA安全需求模型：C1S29
		- 保密性：确保信息资源仅被合法的实体访问-> 信息加密，划分等级分配权限
		- 完整性：信息资源只能以授权方式修改、操作系统的逻辑正确性和可靠性 -> 预防：阻止任何未经授权的改写、检测：发现数据完整性是否遭受破坏
		- 可用性：信息资源可被合法用户访问并按要求的特性使用而不遭拒绝服务 -> 备份与灾难恢复、应急响应、系统容侵
		- 更多需求：C1S34 不可抵赖性、可认证性、可控性、可审查性、可存活性

- 研究的内容 C1S38

- 基本观点

	- 没有一种类型的安全技术、产品能全面保护计算机的安全
	- 安全的强度由安全性最弱的要素来决定
	- 不存在绝对的安全 -> 安全性和可用性、成本投入间的平衡

# Chap3 数据安全--信息加密

- 密码学

	- 发展的几个阶段 C3S3

		- 古典密码学阶段：保密性基于方法（替代、置换），采用手工或初级电子设备方式加解密
		- 密码学形成阶段：保密性基于密钥，采用电子计算机实现加解密
		- 公钥密码体制阶段
		- 量子密码学产生阶段：P=NP时不安全

	- 一般的数据加密模型：公开信道保密通信，要保障传输的信息内容不被第三方获得

	- 组成

		- 明文$m_i$和明文空间$M$

			- 明文是易于理解的信息，对计算机而言是数字化的信息，可以背存储、传输、加工

			- 明文空间：$ M={m=(m1,m2,…,ml)|mi∈X, 1≤ i≤ l }$

				   明文长度为l

				   X称为明文字母表

		- 密文$C_i$和密文空间$C

			- 密文：不易被理解的信息

			- 密文空间：$C={c=(c1,c2.,…,ct)| ci∈Y, 1≤ i≤ t }$

				​    密文长度为t

				​    Y称为密文字母表

		- 密钥空间$K={(Ke,Kd)}$

			- 密钥：加密算法E、解密算法D的运行控制参数

			- 密钥空间：$K={k=(k1,k2,…,ks)| ki∈B, 1≤ i≤ s }$

				​    密钥长度为s

				​    B称为密钥源字母表

		- 加密算法E
			- 本质上是M到C的映射，由$K_e$控制
			- 加密:$c=E_{ke}(m)$
		- 解密算法D
			- 本质上是C到M的映射，由$K_d$控制
			- 解密:$m=D_{kd}(c)=D_{kd}(E_{ke}(m))$

	- 密保系统的分类

		- 按保密内容 C3S12
			- 受限制的算法：基于算法的秘密
			- 基于密钥的算法：基于对密钥的保密
		- 按密钥数量来分 C3S13
			- 对称密码算法：$K_d=K_e$，或其之间存在某种易于发现的关系
				- 最大的问题：ke需要在加密、解密方间交换，密钥的传输、分配是最大问题
			- 非对称密码算法$K_d≠K_e$，或其之间不存在某种易于发现的关系
				- $K_e$不需要保密，可以公开，$K_d$需要保密
		- 按照明文处理方式 C3S14
			- 分组密码：将明文分成固定长度的组，用同一密钥和算法对每一块进行加密，输出也是固定长度的密文
			- 流密码：序列密码一次加密一位、一字节的明文

	- 密码系统的安全性 C3S15

		- 密文出现的概率
		- 完善保密系统的含义 $ I(M;C)=H(M)-H(M|C)=0$，则称相应的密码系统为完善保密系统。知道密文，也不能获取更多明文的信息
		- 密码系统设计的基本原则：确保明文与密文间的互信息为0
		- 完善保密系统的必要条件：$H(K)≥ H(M)$, M和C要完全无关，密钥熵不能小于明文熵,密钥必须具有随机特性，即K应为真正的随机序列
		- 分类
			- 无条件安全  C3S18：无论破译者有多少密文，也无法解出对应的明文 -> 一次性密码，满足H(K) ≥H(M)条件，但大多数场景不适用
			- 计算上安全 C3S19: 破译的代价超出信息本身的价值，时间超出信息的有效期，破译的时间复杂度不是多项式的
		- 研究
			- 密码学
			- 密码编码学
			- 密码分析学（未知密钥）

- 古典密码

	- 塞塔式密码

	- 置换密码

		> 根据一定规则重新安排明文，使其失去可理解特性

		- 缺点：不能抗攻击，甚至是唯密文攻击

	- 替代密码

		> 将明文空间中的一个字符或字符串替换成密文空间中的一个字符或字符串

		- 单表替代密码

			> 一个明文字母对应一个密文字母

			- 形式：$c=E(m)=(am+b)  mod n $(仿射密码)
			- 缺点：不能抗穷举攻击、统计攻击（明文的字母统计特性反映在密文中）

		- 同音替代密码

			> 一个明文字母对应多个密文字母

		- 多表替代密码

			> 由多个单表替代密码构成，一个字母在不同位置被替换成不同的密文字母

			- t个密文本（ t=1为单表替代），加密为：$ci=fi(mi)=(mi+ki) mod 26$,其中ki为密钥,i=0,1,…,t-1

		- 多字母替代密码

	- 一次一密方案

		- 含义：
			- 密钥是真正的随机序列
			- 密钥长度至少等于明文长度
			- 一个密钥只用一次
		- 评价：满足上述三个条件的密码系统是绝对安全的
		- Verman密码：利用异或加密；多表替代密码
		- 问题：密钥如何产生、分配

	- 密码机--轮转机

		- 实质：长周期的多表替代密码

- 现代密码技术 C3S37

	- 序列密码（流密码）

		<img src="https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_informationsecurity/seq.png"/>

		- 密钥序列：需保证随机性
		- 伪随机序列的产生方法：利用反馈移位寄存器来产生伪随机序列

	- 分组密码（块密码）

		- 数字输入序列被划分为长度为n的；密文块为t
		- 一般有t=n，若t>n：有数据扩散的分组密码, t<n：有数据压缩的分组密码
		- 设计原则：足够大的分组长度（否则可穷举明文空间来攻击），密钥空间尽可能大（都则可穷举密钥空间），算法复杂度足够强
		- 基本加密方法
			- 混乱 -> 非线形替代
			- 扩散 -> 明文中的每一位可以影响密文中的许多位，达到雪崩效应
		- Feistel网络
			- 明文分组为$L_0$,$R_0$，通过n次循环处理后，再结合起来生成密文分组
			- 每次循环都以上一次循环产生的$L_{i-1}$,$R_{i-1}$和K产生的子密钥$K_i$作为输入
			- 具体加密解密过程 C3S45
		- DES加密算法
			- 加密过程 C3S48
				- IP置换
				- 16轮变换
					- 选择扩展运算E
					- 选择压缩运算S（DES算法的关键所在，只有该盒是非线性运算，且不易与分析，安全性高）：8个S盒，每盒6位，输出4位 -> 具体构造原则C3S57
					- 置换运算P：目的在于提供雪崩效应（明文或密钥一点小的变动就会引起密文的较大变化）
				- 子密钥的生成
			- 密钥置换算法的构造准则
				- 设计目标是子密钥的统计独立性和灵活性，还需实现简单、速度、不存在简单关系
		- 电子密码本ECB C3S64
			- 特点：简单有效，可并行实现；但不能隐藏明文的模式信息，对明文的主动攻击是有可能的-> 误差传递，适合于传输短信息
		- 密码分组链接CBC C3S66
			- 特点：没有已知的并行实现算法，但能够隐藏明文的模式信息，对明文的主动攻击是不容易的，比ECB安全性好，适合于传输长度大于64位的报文
		- 密码反馈CFB C3S67
			- 特点：分组密码->流密码，没有已知的并行实现算法，需要共同的移位寄存器初始值
		- OFB C3S70
			- 特点：安全性较CFB差
		- 其他分组密码：IDEA、AES C3S75

	- 公钥密码体制（不是无条件安全的）

		- 基本思想

			$ke≠ kd$(ke可公开，kd不行)

		- 基本条件

			- 加密变换和解密变换在计算上是容易的，即其复杂性属于P问题求解的复杂性
			- 密码分析在计算上是困难的，即其复杂性属于NP完全性问题的复杂性

		- 算法条件

			- 产生一对密钥是计算可行的
			- 已知公钥、明文，产生密文是计算可行的
			- 利用私钥、密文，得到明文是计算可行的
			- 利用公钥来推断私钥是计算不可行的
			- 利用公钥、密文，得到明文是计算不可行的
			- 加密和解密的顺序可交换(可选条件)

		- 单向陷门函数

			- 单向函数 eg：$y =a^x $
			- 单向陷门函数（f，t为f相关参数），陷门可作为公钥密码系统的私钥，设计公钥密码体制就在于寻找理想的单向陷门函数
				-  给定x,计算y,使y=f(x)是很容易的
				- 给定y,计算x
					- 当t已知时，计算x=f-1(y) 是很容易的；
					- 当t未知时，计算x=f-1(y) 是很难的

		- RSA算法

			> 公开密钥：(e,n)，保密密钥(d),d、e是可互换的

			> DES算法：
			>
			> 优点：密钥较短，加密处理简单，加解密速度快，适用于加密大量数据的场合。
			>
			> 缺点：密钥单一，不能由其中一个密钥推导出另一个密钥。
			>
			> RSA算法：
			>
			> 优点：应用广泛，加密密钥和解密密钥不一样，一般加密密钥称为私钥。解密密钥称为公钥，私钥加密后只能用公钥解密,，当然也可以用公钥加密，用私钥解密。
			>
			> 缺点：密钥尺寸大，加解密速度慢，一般用来加密少量数据，比如DES的密钥

			- 选取两个大素数p和q（保密）

			- 计算n=pq(公开)，Φ(n)=(p-1)(q-1)
			- 随机选取正整数e（(1<e<Φ(n)），满足gcd(e, Φ(n))=1；e为公开的加密密钥（e、Φ(n)互素），GCD指大公约数
			- 计算d，满足d*e≡ 1(mod Φ(n))（e对于Φ(n) 的模反元素,  d为保密的解密密钥,d与n也是互素的

			<img src="https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_informationsecurity/rsa.png"/>

# Chap4 消息鉴别

> 消息鉴别：证实收到的消息来自可信信源且消息未被篡改的过程
>
> 目的：验证消息源的真实性 & 验证消息的完整性

> - 先校验，再加密
>
> 	- 加密前给明文拼加校验值，加密时，一起加密
>
> 	- 解密后，检查校验值是否一致

#### 1. 基于消息鉴别码的鉴别方法

- 基本思想
	- 发送方A生成$MAC = F(M,K)$，k为密钥，F为鉴别码生成函数
		- 函数特性：为多对一映射，若M相同，存在多个Key产生相同的MAC，若Key相同，多个M产生相同的MAC
	- 将明文M加上MAC传输
	- 接收方生成$MAC' = F(M',K)$，比较MAC‘==MAC
- MAC作用
	- 如果接收方发现MAC匹配，可以确定报文M的完整性（攻击者不知道密钥k，因此不可能计算出一个更改后报文相对应的MAC值）
	- 接收方B也能够确信报文M的真实性（来自发送者A，因为只有A了解密钥K）
	- ⚠️ 但是不能有效防止重放攻击、接收者伪造攻击
- MAC函数与加解密函数比较
	- 相似且都需要密钥
	- MAC函数可以是单向函数，加解密函数需要可逆
	- MAC算法不能提供信息的保密性，保密性可以通过对消息加密来提供
	- 基于MAC的消息鉴别方式、鉴别过程独立于加密、解密过程
	- MAC方式更适合不需要加密保护的数据的鉴别（某些应用中，鉴别真实性比报文的保密性更重要）
- 基于MAC的鉴别方法
	- 基于**消息加密**的MAC生成鉴别方法
		- 不足之处：传输量大（MAC实际传输的数据是明文大小的2倍）；不能防止重放攻击、接收方伪造攻击
	- 基于单向Hash函数和**对称密钥体制**的MAC生成鉴别方法
		- 不足之处：不能防止重放攻击、接收方伪造攻击
	- 基于单向Hash函数和**公钥密码体制**的MAC生成鉴别方法
		- 能防止接收方伪造攻击，不能防止重放攻击
	- 基于**秘密数据块**和单项Hash函数的MAC生成鉴别方法（用于SNMP2协议中）
		- 不足之处：不能防止重放攻击、接收方伪造攻击
- 对MAC强行攻击的难度
	- 验证需要进行多个轮次，直至最后产生一个唯一的密钥
		- 第一轮：选择M1和MAC1，对所有$2^k$个key计算，得到的匹配的密钥数量约等于$2^{k-m}$
		- 第二轮：选择M2和MAC2，对所有$2^{k-m}$个key计算，得到的匹配的密钥数量约等于$2^{k-2m}$
		- ....
		- 进行大约k/m轮
	- 攻击的计算量约为：$2^k+2^{k-m}+2^{k-2m}+......$，可见对于MAC函数强行攻击的难度大于对密码的攻击的难度
- MAC函数设计要点
	- 如果攻击者得到一个M及对应的MAC，则试图构造一个消息M‘使得MAC’=MAC在计算上应该是不可行的
	- MAC函数应该是均匀分布的，即随机选择消息 M 和 M’，MAC = MAC’ 的概率应是 $2^{-m}$，其中 m 是 MAC 的位数
	- 令 M’ 为 M 的某些已知变换，即：M’ = *f* (M)，应保证在这种情况下，MAC = MAC’ 的概率为 $2^{-m}$

#### 2. 单向散列函数 

> $h=H(M)$

- 函数参数

	输入为任意长度，输出必须固定长度

- 函数性质

	> 碰撞则意味着容易伪造，欺骗

	- 单向性质：给定M，容易计算出h；但给定h和H，要找m使H(m)=h时困难的，求逆很困难
	- 弱抗碰撞特性：弱无碰撞，对给定的y，找x，使得H(x)=H(y)是困难的
	- 强抗碰撞特性（生日攻击）：强无碰撞，找x和y，使得H(x)=H(y)是困难的，即发现一个碰撞很难

- 生日攻击：找x和y满足H(x)=H(y),需尝试多少个报文(长度最长为n)？

	- 显然，最多尝试2n＋1个报文，必有一对冲突

- 生日悖论：一群人中，至少有两个人生日相同的概率有多少

	<img src="https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_informationsecurity/bd.png"/>

	- k为何值可以使人群中至少存在两个人生日相同的概率大于50% -> 23人

- 单向散列函数常用设计方法

	- 将消息m分成k组
	- 对每个分组逐一处理，输入是当前分组和上一分组的处理结果 $h_i = H(m_i,h_{i-1})$
	- 最后一个分组处理结果$h_k$是整个消息的散列值

- 常用的单向散列函数 C4S22

	- MD5

		> 不是强无碰撞的，在法律意义上不安全

		- 输入：任意长度的消息M
		- 输出：定长为128位的消息散列值
		- 算法：
			- 填充比特位：先附加一位1，然后附加多位0，直到L≡448(mod 512）（如果在填充前已经满足L≡448(mod 512)， 则在消息后附加1位1和511位0）
			- 附加消息长度：在第一步基础上再附加64位的消息长度信息（进行步骤1前消息的长度）
			- 初始化寄存器：4个32位寄存器
			- 计算散列值（核心）：64次变换，每次变换参数不同，函数形式相同
			- 散列值输出
