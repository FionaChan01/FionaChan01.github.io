---
title: 'FiFi‘s Blog：About GRE'
date: 2022-04-30
permalink: /posts/2022/04/blog-post-gre/
tags:
  - Language	
  - Life Sharing
  - Growth Mindset
---

肥肥碎碎念 ｜ 关于GRE的一切

-----

### 写在前面

> GRE真的是我遇到过最难的语言考试了。
>
> 学习的过程十分令人折磨：单词背了就忘、题做了又错、投入了时间感觉却毫无效果。这两个半月的日子里，我时常与泪水和煎熬相伴。不得不说，出国的路是孤寂的，花费大量的精力在语言考试上，看到的也不过只是一条无尽头的路，自己像是唯一一位伴着星光，但却总是与黑夜相守的赶路人。22年3月份的时候，我在纸质版的《要你命3000》上看到了这样一句话：“独上高楼，望尽天涯路”，那一瞬间的共鸣是巨大的，好像终于，有人能描述同样的孤单与慰藉，倒显得并没有那么寂寞了。而我也逐渐意识到，虽然困难，可是这必须是我要走的路，甚至，他可能只是道门，一道我必须敲开踏进去，往里走的门。
>
> 不过感谢老天和我自己都待我不薄，终于在22年4月24日，经历了无比艰难的两个月，我考到了326分 (V156 + Q170 + 3)。这显然不是个高分，甚至于我来说，它只是一个看的过眼，平平无奇，将个烂就，不至于拖后腿的分数。但是我满足了，真的满足了，因为我好像没有那么多时间，留给GRE了，而这两个半月来的努力看似也没有白费。
>
> 所以希望现在的这篇经验随笔，能够有幸帮助到看到的你，不管是精神上还是真正的语言学习上，希望它能予你以小小的鼓励------千万，千万，不要放弃！

### General Advices

对于GRE这种考试，我觉得最适合的学习方式应该是**快准狠**。人类的记忆曲线规律注定了长时间过后的遗忘，而GRE这种涉及到的非常大量生僻字的考试，对于长战线的复习简直就是噩梦。我亲身体验过踩坑般的学习，花了大半年想要记住单词后再开始学习，尽管我严格按照计划每天背单词，但由于记忆无法持久，没有测验激励，生活中不会重复巩固，导致这根本没在我事到临头不得不学GRE的时刻起到一点帮助。

所以，以下的所有分享，我都建议大家拿出：每天尽量大段的时间（假期脱产复习是最好）、万分集中的精力，来短时间攻克GRE。

### 学习顺序

- **扫盲**

  - 请先看GRE考试扫盲视频：内含GRE的流程、考试内容介绍 
  <a>
  https://www.bilibili.com/video/BV1NK4y1s7Z7
  </a>

- **单词**

  - GRE对于初学者来说，一定一定是一个单词考试。我在这两个月的学习时间内，也基本上是每天花费2h-6h的时间在记忆单词上，可以说，单词绝对是GRE的重中之重，初学时花费大量的时间在单词上也是必要且值得的，因为V中的填空需要大量的词汇量去完成。千万不要一上来就做题，真的会得不偿失。

    - 最好的单词书：《GRE核心词汇考法精析》（要你命3000）

      <a>https://book.douban.com/subject/6848105/</a>

    - 我使用的软件：墨墨背单词【超级推荐，需要付费购买单词量】

    	剂量：我大概是每天100个新词复习200-300个左右，这个速度差不多一个月搞定单词关

  - 我当时为了追求高效背单词（因为真的好难啊这单词），专门买了杨鹏老师的《17天搞定GRE单词》，但是实际上读下来，感觉指导意义不是特别大，其中大部分在我看来是比较鸡汤的内容，个人认为只有背词的安排日程表和混词表较为有用。不过里面很有建设性的指导思想就是：简单化快速记忆，即不要追求完完全全认识一个单词，一定必须要中->英，英->中，可以听识完全顺畅才算背完，GRE本身只是一个纸面上的考试，看到单词，秒出中文意思，目标就达到了。没有必要在单词量需求如此大，如此怪（对不起ETS，但是我觉得有的单词真的怪啊，中文意思我都无法理解😾）的考试里表现自己的英语水平。咱一切一切的目的就是：快准狠搞定🤝

  	​	<a>https://book.douban.com/subject/25749879/</a>

  	单词的记忆是最难也是最简单的，没有任何诀窍、神话，没有任何一个杀G人能逃脱，而唯一的秘诀只有：重复、重复、再重复。相信我，过了单词关，这趟必经之路就已经在半途了！

- **长难句**

	- 建议就是在背单词积累词汇时先别做题，因为verbal的填空可以说完完全全依赖词汇量，直到大家觉得可以背住70%的单词后再开始开始做题，在题中记忆巩固剩余单词和顽固词汇。然后背单词的同时我认为可以适当加入长难句练习，因为这个v的阅读对长难句的考察也是很多的。
	- 此处推荐杨鹏老师的另一本著作《GRE、GMAT阅读难句教程》，这本书绝对是五星，方法论完善、独到、一针见血。主要思想就是：读意群、学会默读、快读、不回视、合理化推理未知词汇、练习阅读速度。我个人是初期每天练习大概10-20句长难句，直到差不多20天把这本书看完。



```f
//
// Created by FiFi on 2022/5/8.
//

#ifndef COMLAB2_GRAMMAR_H
#define COMLAB2_GRAMMAR_H

#include <iostream>
#include "set"
#include "vector"
#include "map"
#include "cstring"

using namespace std;

class Grammar {
private:
    set<string> Vt;
    set<string> Vn;
    string s ="<程序>";
    set<pair<string, vector<string>>> p;
    map<string,set<string>> first;
    map<string, set<string>> follow;

public:
    const set<string> &getVt() const {
        return Vt;
    }

    void setVt(const set<string> &vt) {
        Vt = vt;
    }

    const set<string> &getVn() const {
        return Vn;
    }

    void setVn(const set<string> &vn) {
        Vn = vn;
    }



    const set<pair<string, vector<string>>> &getP() const {
        return p;
    }

    void setP(const set<pair<string, vector<string>>> &p) {
        Grammar::p = p;
    }

    // add grammar--------------
    Grammar() {
        // 非终结符集合，所有不在非终结符集合中的都为终结符
        Vn = {"<参数表1>", "<缺省>", "<无返回值函数调用语句>", "<表达式2>", "<值参数表1>", "<有返回值函数定义>", "<乘法运算符>", "<表达式>", "<变量说明>",
              "<返回语句>", "<项1>", "<值参数表>", "<情况子语句>", "<赋值语句>", "<条件不成立语句>", "<无符号整数>", "<情况表>", "<字符>", "<项>", "<读语句>",
              "<常量定义int>", "<字符串>", "<语句>", "<常量定义>", "<条件语句>", "<条件>", "<语句列>", "<整数>", "<变量定义无初始化1>", "<参数表>",
              "<常量1>", "<关系运算符>", "<类型标识符>", "<因子>", "<加法运算符>", "<标识符>", "<表达式1>", "<变量定义及初始化>", "<写语句>", "<变量定义无初始化>",
              "<主函数>", "<循环语句>", "<步长>", "<变量定义>", "<常量定义char>", "<复合语句>", "<情况表1>", "<常量2>", "<变量定义及初始化1>",
              "<无返回值函数定义>", "<程序>", "<情况语句>", "<声明头部>", "<有返回值函数调用语句>", "<常量说明>", "<常量>"};

        p.insert(make_pair("<加法运算符>", vector<string>{"+"}));
        p.insert(make_pair("<加法运算符>", vector<string>{"-"}));
        p.insert(make_pair("<乘法运算符>", vector<string>{"*"}));
        p.insert(make_pair("<乘法运算符>", vector<string>{"/"}));
        p.insert(make_pair("<关系运算符>", vector<string>{"<"}));
        p.insert(make_pair("<关系运算符>", vector<string>{"<="}));
        p.insert(make_pair("<关系运算符>", vector<string>{">"}));
        p.insert(make_pair("<关系运算符>", vector<string>{">="}));
        p.insert(make_pair("<关系运算符>", vector<string>{"=="}));
        p.insert(make_pair("<关系运算符>", vector<string>{"!="}));
        p.insert(make_pair("<字符>", vector<string>{"CHARCON"}));
        p.insert(make_pair("<字符串>", vector<string>{"STRCON"}));
        p.insert(make_pair("<程序>", vector<string>{"<常量说明>", "<变量说明>", "<有返回值函数定义>", "<主函数>"}));
        p.insert(make_pair("<程序>", vector<string>{"<常量说明>", "<变量说明>", "<无返回值函数定义>", "<主函数>"}));
        p.insert(make_pair("<常量说明>", vector<string>{"ε"}));
        p.insert(make_pair("<有返回值函数定义>", vector<string>{"ε"}));
        p.insert(make_pair("<无返回值函数定义>", vector<string>{"ε"}));
        p.insert(make_pair("<常量说明>", vector<string>{"const", "<常量定义>", ";", "<常量说明>"}));
        p.insert(make_pair("<变量说明>", vector<string>{"ε"}));
        p.insert(make_pair("<常量定义>", vector<string>{"int", "<标识符>", "=", "<整数>", "<常量定义int>"}));
        p.insert(make_pair("<常量定义>", vector<string>{"char", "<标识符>", "=", "<字符>", "<常量定义char>"}));
        p.insert(make_pair("<常量定义char>", vector<string>{",", "<标识符>", "=", "<字符>", "<常量定义char>"}));
        p.insert(make_pair("<常量定义char>", vector<string>{"ε"}));
        p.insert(make_pair("<常量定义int>", vector<string>{",", "<标识符>", "=", "<整数>", "<常量定义int>"}));
        p.insert(make_pair("<常量定义int>", vector<string>{"ε"}));
        p.insert(make_pair("<无符号整数>", vector<string>{"INTCON"}));
        p.insert(make_pair("<整数>", vector<string>{"+", "<无符号整数>"}));
        p.insert(make_pair("<整数>", vector<string>{"-", "<无符号整数>"}));
        p.insert(make_pair("<标识符>", vector<string>{"IDENFR"}));
        p.insert(make_pair("<声明头部>", vector<string>{"<整数>"}));
        p.insert(make_pair("<声明头部>", vector<string>{"<字符>"}));
        p.insert(make_pair("<变量说明>", vector<string>{"<变量定义>", ";", "<变量说明>"}));
        p.insert(make_pair("<变量定义>", vector<string>{"<变量定义无初始化>"}));
        p.insert(make_pair("<变量定义>", vector<string>{"<变量定义及初始化>"}));
        p.insert(make_pair("<变量定义无初始化>", vector<string>{"<类型标识符>", "<标识符>", "<变量定义无初始化1>"}));
        p.insert(make_pair("<变量定义无初始化1>", vector<string>{",", "<标识符>", "<变量定义无初始化1>"}));
        p.insert(make_pair("<变量定义无初始化>", vector<string>{"<类型标识符>", "<标识符>", "[", "<无符号整数>", "]", "<变量定义无初始化1>"}));
        p.insert(make_pair("<变量定义无初始化1>", vector<string>{",", "<标识符>", "[", "<无符号整数>", "]", "<变量定义无初始化1>"}));
        p.insert(make_pair("<变量定义无初始化>", vector<string>{"<类型标识符>", "<标识符>", "[", "<无符号整数>", "]", "[", "<无符号整数>", "]",
                                                        "<变量定义无初始化1>"}));
        p.insert(make_pair("<变量定义无初始化1>",
                           vector<string>{",", "<标识符>", "[", "<无符号整数>", "]", "[", "<无符号整数>", "]", "<变量定义无初始化1>"}));
        p.insert(make_pair("<变量定义无初始化1>", vector<string>{"ε"}));
        p.insert(make_pair("<变量定义及初始化1>", vector<string>{"ε"}));
        p.insert(make_pair("<变量定义及初始化1>", vector<string>{",", "<标识符>", "=", "<常量>"}));
        p.insert(make_pair("<变量定义及初始化1>", vector<string>{",", "<标识符>", "=", "<常量>"}));
        p.insert(make_pair("<变量定义及初始化1>", vector<string>{",", "<标识符>", "[", "<无符号整数>", "]", "=",
                                                         "{", "<常量>", "<常量1>", "}"}));
        p.insert(make_pair("<变量定义及初始化>", vector<string>{"<类型标识符>", "<标识符>", "=", "<常量>", "<变量定义及初始化1>"}));
        p.insert(make_pair("<变量定义及初始化>", vector<string>{"<类型标识符>", "<标识符>", "[", "<无符号整数>", "]", "=",
                                                        "{", "<常量>", "<常量1>", "}", "<变量定义及初始化1>"}));
        p.insert(make_pair("<变量定义及初始化>", vector<string>{"<类型标识符>", "<标识符>", "[", "<无符号整数>", "]", "[",
                                                        "<无符号整数>", "]", "=", "{", "{", "<常量>", "<常量1>", "}", "<常量2>",
                                                        "}", "<变量定义及初始化1>"}));
        p.insert(make_pair("<常量1>", vector<string>{",", "<常量>", "<常量1>"}));
        p.insert(make_pair("<常量1>", vector<string>{"ε"}));
        p.insert(make_pair("<常量2>", vector<string>{",", "{", "<常量>", "<常量1>", "}"}));
        p.insert(make_pair("<常量>", vector<string>{"CHARCON"}));
        p.insert(make_pair("<常量>", vector<string>{"INTCON"}));
        p.insert(make_pair("<常量>", vector<string>{"STRCON"}));
        p.insert(make_pair("<类型标识符>", vector<string>{"int"}));
        p.insert(make_pair("<类型标识符>", vector<string>{"char"}));
        p.insert(make_pair("<有返回值函数定义>", vector<string>{"<声明头部>", "(", "<参数表>", ")", "{", "<复合语句>", "}"}));
        p.insert(make_pair("<无返回值函数定义>", vector<string>{"void", "<标识符>", "(", "<参数表>", ")", "{", "<复合语句>", "}"}));
        p.insert(make_pair("<复合语句>", vector<string>{"<常量说明>", "<变量说明>", "<语句列>"}));
        p.insert(make_pair("<参数表>", vector<string>{"<类型标识符>", "<标识符>", "<参数表1>"}));
        p.insert(make_pair("<参数表1>", vector<string>{",", "<类型标识符>", "<标识符>", "<参数表1>"}));
        p.insert(make_pair("<参数表>", vector<string>{"ε"}));
        p.insert(make_pair("<参数表1>", vector<string>{"ε"}));
        p.insert(make_pair("<表达式1>", vector<string>{"ε"}));
        p.insert(make_pair("<主函数>", vector<string>{"void", "main", "(", ")", "<复合语句>"}));
        p.insert(make_pair("<表达式>", vector<string>{"+", "<项>", "<表达式1>"}));
        p.insert(make_pair("<表达式>", vector<string>{"-", "<项>", "<表达式1>"}));
        p.insert(make_pair("<表达式1>", vector<string>{"<加法运算符>", "<项>", "<表达式1>"}));
        p.insert(make_pair("<项>", vector<string>{"<因子>", "<项1>"}));
        p.insert(make_pair("<项1>", vector<string>{"<乘法运算符>", "<因子>", "<项1>"}));
        p.insert(make_pair("<项1>", vector<string>{"ε"}));
        p.insert(make_pair("<因子>", vector<string>{"<标识符>"}));
        p.insert(make_pair("<因子>", vector<string>{"<标识符>", "[", "<表达式>", "]"}));
        p.insert(make_pair("<因子>", vector<string>{"<标识符>", "[", "<表达式>", "]", "[", "<表达式>", "]"}));
        p.insert(make_pair("<因子>", vector<string>{"(", "<表达式>", ")"}));
        p.insert(make_pair("<因子>", vector<string>{"<整数>"}));
        p.insert(make_pair("<因子>", vector<string>{"<字符>"}));
        p.insert(make_pair("<因子>", vector<string>{"<有返回值函数调用语句>"}));
        p.insert(make_pair("<语句>", vector<string>{"<循环语句>"}));
        p.insert(make_pair("<语句>", vector<string>{"<情况语句>"}));
        p.insert(make_pair("<语句>", vector<string>{"ε", ";"}));
        p.insert(make_pair("<语句>", vector<string>{"<条件语句>"}));
        p.insert(make_pair("<语句>", vector<string>{"<有返回值函数调用语句>", ";"}));
        p.insert(make_pair("<语句>", vector<string>{"<无返回值函数调用语句>", ";"}));
        p.insert(make_pair("<语句>", vector<string>{"<赋值语句>", ";"}));
        p.insert(make_pair("<语句>", vector<string>{"<读语句>", ";"}));
        p.insert(make_pair("<语句>", vector<string>{"<写语句>", ";"}));
        p.insert(make_pair("<语句>", vector<string>{"<返回语句>", ";"}));
        p.insert(make_pair("<语句>", vector<string>{"{", "<语句列>", "}"}));
        p.insert(make_pair("<赋值语句>", vector<string>{"<标识符>", "=", "<表达式>"}));
        p.insert(make_pair("<赋值语句>", vector<string>{"<标识符>", "[", "<表达式>", "]", "=", "<表达式>"}));
        p.insert(make_pair("<赋值语句>", vector<string>{"<标识符>", "[", "<表达式>", "]", "[", "<表达式>", "]", "=", "<表达式>"}));
        p.insert(make_pair("<条件语句>", vector<string>{"if", "(", "<条件>", ")", "<语句>", "<条件不成立语句>"}));
        p.insert(make_pair("<条件不成立语句>", vector<string>{"else", "<语句>"}));
        p.insert(make_pair("<条件不成立语句>", vector<string>{"ε"}));
        p.insert(make_pair("<条件>", vector<string>{"<表达式>", "<关系运算符>", "<表达式>"}));
        p.insert(make_pair("<循环语句>", vector<string>{"while", "(", "<条件>", ")", "<语句>"}));
        p.insert(make_pair("<循环语句>",
                           vector<string>{"for", "(", "<标识符>", "=", "<表达式>", ";", "<条件>", ";", "<标识符>", "=", "<标识符>",
                                          "+", "<步长>", ")", "<语句>"}));
        p.insert(make_pair("<循环语句>",
                           vector<string>{"for", "(", "<标识符>", "=", "<表达式>", ";", "<条件>", ";", "<标识符>", "=", "<标识符>",
                                          "-", "<步长>", ")", "<语句>"}));
        p.insert(make_pair("<步长>", vector<string>{"<无符号整数>"}));
        p.insert(make_pair("<情况语句>", vector<string>{"switch", "(", "<表达式>", ")", "{", "<情况表>", "<缺省>", "}"}));
        p.insert(make_pair("<情况表>", vector<string>{"<情况子语句>", "<情况表1>"}));
        p.insert(make_pair("<情况表1>", vector<string>{"<情况子语句>", "<情况表1>"}));
        p.insert(make_pair("<情况表1>", vector<string>{"ε"}));
        p.insert(make_pair("<情况子语句>", vector<string>{"case", "<常量>", ":", "<语句>"}));
        p.insert(make_pair("<缺省>", vector<string>{"default", ":", "<语句>"}));
        p.insert(make_pair("<有返回值函数调用语句>", vector<string>{"<标识符>", "(", "<值参数表>", ")"}));
        p.insert(make_pair("<无返回值函数调用语句>", vector<string>{"<标识符>", "(", "<值参数表>", ")"}));
        p.insert(make_pair("<值参数表>", vector<string>{"<表达式>", "<值参数表1>"}));
        p.insert(make_pair("<值参数表1>", vector<string>{",", "<表达式>", "<值参数表1>"}));
        p.insert(make_pair("<值参数表1>", vector<string>{"ε"}));
        p.insert(make_pair("<值参数表>", vector<string>{"ε"}));
        p.insert(make_pair("<语句列>", vector<string>{"{", "<语句>", "}"}));
        p.insert(make_pair("<读语句>", vector<string>{"scanf", "(", "<标识符>", ")"}));
        p.insert(make_pair("<写语句>", vector<string>{"printf", "(", "<字符串>", ",", "<表达式>", ")"}));
        p.insert(make_pair("<写语句>", vector<string>{"printf", "(", "<字符串>", ")"}));
        p.insert(make_pair("<写语句>", vector<string>{"printf", "(", "<表达式>", ")"}));
        p.insert(make_pair("<返回语句>", vector<string>{"return", "<表达式2>"}));
        p.insert(make_pair("<表达式2>", vector<string>{"(", "<表达式>", ")"}));
        p.insert(make_pair("<表达式2>", vector<string>{"ε"}));
    }

    set<string> FIRST(string X) {
        set<string> FIRSTchar;
        // 空串的FIRST集只有其本身
        if (X=="ε"){
            FIRSTchar.insert("ε");
            return FIRSTchar;
        }
        // 终结符的FIRST集只有其本身
        if (Vn.find(X)==Vn.end()) {
            FIRSTchar.insert(X);
            return FIRSTchar;
        }
            // 对非终结符
        else{
            for (auto i:p){
                // 若产生式右部只有空
                if (i.first==X && i.second[0]=="ε")
                    FIRSTchar.insert("ε");
                // 若不是空，相当于求右部串的FIRST集
                else if(i.first==X){
                    vector<string> right = i.second;
                    set<string> tempset = FIRST1(X,right);
                    for (const auto& j : tempset)
                        FIRSTchar.insert(j);
                }
            }
        }
        return FIRSTchar;
    }

    set<string> FIRST1(const string& X, vector<string> pRight) {
        set<string> firstString;
        int i = 0;
        // 找到串里第一个FIRST集里不含空的单元
        set<string> temp = FIRST(pRight[i]);
        while (i<pRight.size() && temp.find("ε")!=temp.end()){
                i++;
                temp = FIRST(pRight[i]);
        }
        //全部的first集里都有空
        if (i==pRight.size())
            firstString.insert("ε");
        // 第一个元素的first集就没有空了
        if (i==0){
            firstString = FIRST(pRight[0]);
        }
        // i是第一个first集里没有空的词的索引
        for (int j =0 ;j<i;j++) {
            if (X != pRight[j])
                for (const auto& k : FIRST(pRight[j])){
                    // 防止死循环，因为此时正在求该符号的FIRST，所以其自身的FISRT集可以不放入
                    if (k != "ε")
                        firstString.insert(k);
                }
        }
        return firstString;
    }

    set<string> FIRST(vector<string> s) {
        set<string> firsts;
        int i = 0;

         set<string> temp = FIRST(s[i]);
         while (i<s.size() && temp.find("ε")!=temp.end()){
             i++;
             if (i<s.size())
                temp = FIRST(s[i]);
         }
        //全部的first集里都有空
        if (i==s.size())
            firsts.insert("ε");
        // 第一个元素的first集就没有空了
        if (i==0){
            string s1 = s[0];
            firsts = FIRST(s1);
        }
        // i是第一个first集里没有空的词的索引
        for (int j =0 ;j<i;j++) {
            string myChar = s[j];
            for (string myChar1 : FIRST(myChar)){
                if (myChar1!="ε")
                    firsts.insert(myChar1);
            }
        }
        return firsts;
    }

    map<string, set<string>> FOLLOW() {
        map<string, set<string>> FOLLOW;
        // 每个终结符的FOLLOW初始化为空集合
        for (auto i:Vn)
            FOLLOW.insert(make_pair(i,set<string>{}));
        // 将结束符放入开始符的FOLLOW集中
        FOLLOW[s].insert("$");
        while(true){
            // 假设每个FOLLOW都没有增加了
            bool flag = true;
            // 遍历每个非终结符
            for (auto i:Vn){
                // 遍历每条产生式
                for (auto j : p){
                    string A = j.first;
                    vector<string> right = j.second;
                    // 若产生式右部含有该非终结符
                    auto t = right.begin();
                    if ((t = std::find(right.begin(), right.end(), i))!=right.end()){
                        vector<string> alpha(right.begin(),t);
                        vector<string> beta(t+1,right.end());
                        if (!beta.empty()){
                            // 若beta不为空，则将FIRST（beta）除空字符串以外的符号加入FOLLOW（B）
                            for (auto k: FIRST(beta)){
                                if(k!="ε"){
                                    set<string> tempSet = FOLLOW[i];
                                    int before = tempSet.size();
                                    tempSet.insert(k);
                                    int after = tempSet.size();
                                    FOLLOW[i]=tempSet;
                                    // 若某个集合增加了大小
                                    if (before!=after)
                                        flag = false;
                                }
                            }
                        }
                        // 若为空，或者其FIRST集中有空字符串，则将FOLLOW(A)放入FOLLOW(B)中

                        set<string> ts;
                        if (beta.size()!=0)
                            ts = FIRST(beta);
                        if (beta.size()==0 || ts.find("ε")!=ts.end()){
                            set<string> tempSetB = FOLLOW[i];
                            set<string> tempSetA = FOLLOW[A];
                            int before = tempSetB.size();
                            for(const auto& m : tempSetA)
                                tempSetB.insert(m);
                            int after = tempSetB.size();
                            FOLLOW[i]=tempSetB;
                            // 若某个集合增加了大小
                            if (before!=after)
                                flag = false;
                        }
                    }
                }
            }
            // 若没有集合增加了大小
            if (flag)
                break;
        }
        return FOLLOW;
    }

    map<pair<string,string>, ProductionForm> TABLE(Grammar grammar,
                                                  Map<MyChar, Set<MyChar>> FOLLOW) {
        Map<TwoTuple, ProductionForm> TABLE = new HashMap<>();
        // 遍历所有的产生式
        for (ProductionForm productionForm : grammar.getProductionForms()) {
            List<MyChar> alpha = productionForm.getRight();
            MyChar A = productionForm.getLeft();
            // 对FIRST（alpha）中的每一个非终结符a，将A -> alpha 加入到 TABLE[A,a]中
            for (MyChar character : FIRST(alpha,grammar)) {
                if (grammar.getTerminators().contains(character) && !character.getChar().equals("ϵ"))
                    TABLE.put(new TwoTuple(A, character), productionForm);
            }
            // 若FIRST集中有空字符串，对FOLLOW（A）中的每一个字符b，将A -> alpha 加入到TABLE[A,b]中
            if (FIRST(alpha,grammar).contains(new MyChar("ϵ"))) {
                for (MyChar character : FOLLOW.get(A)) {
                    if (grammar.getTerminators().contains(character) && !character.getChar().equals("ϵ")) {
                        TABLE.put(new TwoTuple(A, character), productionForm);
                    }
                }
                // 若终止符在FOLLOW中，将 A -> alpha 加入到TABLE[A, $] 中
                if (FOLLOW.get(A).contains(new MyChar("$"))) {
                    TABLE.put(new TwoTuple(A, new MyChar("$")), productionForm);
                }
            }

        }
        return TABLE;
    }


};

#endif //COMLAB2_GRAMMAR_H
```