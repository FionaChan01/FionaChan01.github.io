---
title: 'FiFi‘s School Work: Compilers'
date: 2022-05-02
permalink: /posts/2022/05/blog-post-compilers/
tags:
  - CS
  - Knowledge
---

重庆大学计算机学院 ｜ 22Spring ｜ 编译原理

## 一. 词法分析

## 二. 语法分析

> 语法分析器使用词法分析器中生成的各个词法单元的第一个分量来创建树形的中间表示，利用其（多为语法树）给出词法单元流的语法结构

#### 语法树

每个内部节点代表一个运算，节点的子节点表示该运算的分量



### Ⅰ 相关概念

- 句型：S 推倒出 α，而S是文法G的开始符号，则α是G的句型
- 句子：不包含非终结符号的句型
- 语言：文法生成的所有句子的集合
- 上下文无关语言：可以由文法生成的语言
- 等价文法：两个文法生成相同的语言

### Ⅱ 上下文无关文法

> 文法描述了大多数程序设计语言构造的层次化语法模型。
>
> 一个上下文无关文法由：一个终结符号集合（小写字母，运算符，标点符，数字，黑体字符串）、一个非终结符号集合（大写字母，小写、斜体的名字，字母表排在后面的小写字母，小写的希腊字母）、一个产生式集合和一个指定的非终结符号为开始符号组成。

#### 1. 二义性

> 一个文法可以为某个句子生成多棵语法分析树 <--> 对同一个句子有多个最左推导或最右推导的文法

#### 2. 两种推导过程

- 最左推导 Leftmost Deviation
	- 总是选择每个句型的最左非终结符号，写作$lm$
- 最右推导 Rightmost Deviation（规范推导）
	- 总是选择最右边的非终结符号，写作$rm$

#### 3. 语法分析树的常用构造方法

- 自顶向下的
	- 从语法树的顶部（根结点）开始向底部（叶子结点）构造语法分析树
	- 不能应用于带左递归文法的语法分析
- 自底向上的
	- 从叶子结点开始向根结点方向扫描构造语法分析树
	- “最右”推导

### Ⅲ 设计文法

#### 1. 二义性的消除

- 中间的语句不能以一个尚未匹配的语句结尾 P134

#### 2. 左递归的消除

> 如果一个文法中有一个非终结符号A使得对某个串å存在一个推导：A -> Aα，则称这个文法有左递归

- 如何替换

	- 直接左递归
		$$
		A -> Aα | ß    \   替换为：   A -> ßA'     ;\         A' -> αA' | ε
		$$

	- 间接左递归

		方法类似

	- 无环左递归

		![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/GsyxIK.png)

#### 3. 左公因子的提取

> 一种文法转换方法，可以适用于预测分析技术或自顶向下分析技术的文法

- 对于产生式
	$$
	 A -> αβ_1 | αβ_2 | η 
	$$
	
- $$
	A -> αA | η';\ Α' -> β_1|β_2
	$$

	

#### 4. 非上下文无关语言的构造

> C、Java这种语言是非上下文无关的，因为都要求标识符先声明后使用，在这些语言的编译器中，标识符是否先声明后使用是在语义分析阶段检查的

### Ⅳ 自顶向下的语法分析

> 可以被看成为输入串构造语法分析树的问题：从根结点开始按照深度优先的场景语法分析树的各个节点（寻找最左推导过程）
>
> 🏆关键：确定对一个非终结符号应用哪一个产生式

#### 1. 递归下降的语法分析

> 由一组过程组成，每个非终结符号有一个对应的过程，程序的执行从开始符号对应的过程开始，如果这个过程的过程体扫描了整个输入串，他就停止并宣布语法分析完成

- 通用的递归下降分析可能需要回溯：最初选择产生式的时候不确定
- 左递归的文法会使递归下降的语法分析器进入一个无限循环♾️

#### 2. First 和 Follow

> First(α) ：可从**α推导得到的串的首符号集合**，其中α是任意的文法符号串，该集合中可包含ε
>
> Follow(A)：对于非终结符号A，该集合被定义为可能在**某些句型中紧跟在A右边的终结符号的集合**，可包括$（结束标记）

- 计算**各个文法符号X的First(X)规则**：不断应用该规则，直至没有新的终结符号或ε可以被加入到任何的First集合中为止

	- 如果X是一个终结符号，那么First(X) = X
	- 如果X是一个非终结符号，且$X -> Y_1Y_2...Y_k$是一个产生式，k≥1，那么对于某个i，a在Firtst($Y_i$)中且ε在所有的First($Y_1$), First($Y_2$), ..., First($Y_(i-1)$)中，那么就把a加入First(X)
	- 如果$X->ε$是一个产生式，那么将ε加入到First(X)中

- 计算**串$X_1X_2...X_k$的First(X)规则**：

	- 加入F($X_1$)的所有非ε符号，若ε在F($X_1$)中，则加入F($X_2$)的所有非ε符号，以此类推，若所有的i，ε都在First($X_i$)中，则加入ε

- 计算所有**非终结符号A的Follow(A)集合的规则**：不断应用该规则，直到没有新的终结符号可以被加入到任意Follow集合中为止

	> 🥹 注意记录Follow(x) 是在哪个Follow(y)里，这样循环的时候好发现

	- 将$（输入右端的结束标记） 放到Follow(S)中，其中S是开始符号
	- 如果存在一个产生式$A->αBβ$，那么First(β)中出了ε之外的所有符号都在Follow(B)中
	- 如果存在一个产生式$A->αB$，或$A->αBβ$，且First(β)包含ε，那么Follow(A)中的所有符号都在Follow(B)中

#### 3. LL(1)文法

> 可以通过该文法构造出预测分析器（无需回溯的递归下降语法分析器）
>
> 第一个“L”表示从左向右扫描输入，第二个“L”表示产生最左推导，“1”表示在每一步中只需要向前看一个输入符号来决定语法分析的动作
>
> 该文法足以描述大部分程序设计语言构造，但注意⚠️：左递归的文法和二义性的文法都不可能是LL(1)的

- **判断文法G是否为LL(1)的**，当且仅当G的任意两个产生式$A->α | β$满足下面的条件：
	- ① FIRST(α)和FIRST(β)是不相交的集合
		- 不存在终结符号a使得α和β都能够推导出以a开头的串
		- α和β中最多只有一个可以推导出空串
	- ② 如果ε在FIRST(β)中，那么 FIRST(α)和FOLLOW(A)是不想交的集合；在FIRST(α)中亦然
		- β能推出空，那么α不能推导出任何以Follow(A)中某个终结符号开头的串；α亦然

- 构建**预测分析表**的算法

	> ⚠️注意：细节如：｜的处理
	>
	> 如果该文法存在左递归或者二义性，那么分析表M至少会包含一个多重定义的条目

	- 对于文法G的每个产生式 $A->α$，进行如下处理：
		- 对于FIRST(α)中的每个终结符号a，将$A->α$ 加入M[A,a]中
		- 如果ε在FIRST(α)中，那么对于FOLLOW(A)中的每个终结符号b，将$A->α$加入到M[A,b]中。如果ε在FIRST(α)中，且\$在FOLLOW(A)中，也将$A->α$加入到M[A,$]中
		- 完成以上操作后，如果M[A,a]中没有产生式，则将其设置为error（或空条目）

#### 4. 非递归的预测分析

> [非递归](https://so.csdn.net/so/search?q=非递归&spm=1001.2101.3001.7020)的预测分析**不需要**为每个非终结符**编写递归下降过 程**，而是根据预测分析表构造一个**自动机**，也叫**表驱动的预测分析。**即增加一个栈，来**增强自动机的识别能力**

- 表驱动的预测语法分析

	https://www.bilibili.com/video/BV1zW411t7YE?p=24

	![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/ll1.png)

#### 5. 预测分析的错误恢复

- 错误恢复策略
	- 恐慌模式
	
		恐慌模式的恢复：语法分析器一旦发现错误就不断丢弃输入中的符号，知道找到同步词法单元集合中的某个元素
	
		- 同步集合的选取：
			- 将Follow(A)中的所有符号放到非终结符号A的同步集合中
			- 把较高层构造的开始符号加入到较低层构造的同步集合中去
			- 把First(A)中的符号加入到非终结符号A的同步集合中去
			- ... P146
	
	- 短语层次恢复
	
		短语层次的恢复：在余下的输入上进行局部性纠正
	
	- 其他
	
		- 错误产生式
	
		- 全局纠正
	

### Ⅴ 自底向上的语法分析

> 对应为一个输入串构造语法分析树的过程，从叶子结点逐渐向上到达根结点，构造过程较为方便
>
> 目的😄：反向构造一个推导过程（最右推导）

#### 1. 移入、规约语法分析技术

- 规约

> 将自底向上语法分析过程看成将一个串w规约为文法开始符号的过程，在规约的步骤中，一个与某产生式体相配的特定子串被替换为该产生式头部的非终结符号

- 短语、句子、句柄

> 相关概念✈️：https://blog.csdn.net/qq_43543789/article/details/104818368
>
> 短语：语法树中任一子树叶结点所组成的符号串
>
> 直接短语：子树中不再包含其他的子树
>
> 句柄 handle：**直接短语中的最左直接短语为该句型的句柄**（若为二义性文法，则可能存在不止一个最右推导，不止一个句柄）
>
> 句柄是和某个产生式体相匹配的子串，子串中既可能包括终结符号，也可能包括非终结符号。⚠️ 如果其中包括非终结符号，那么字符串必然经过了一次或多次归约。

- 移入、规约语法分析技术 -- 简单LR技术

	- 自底向上语法分析的一种形式

	- 方法

		- 栈保存文法符号，输入缓冲区存放将要语法分析的剩余符号
		- 对输入栈的从左到右扫描过程中，语法分析器将0个或多个输入符号移到栈的顶端，知道可以对栈顶的一个文法符号串β进行规约（替换成产生式头部的非终结符）为止
		- 将β规约为某个产生式的头
		- 循环知道检测到语法错误或者栈中包括开始符号且输入缓冲区为空为止

	- 可能的动作

		- 移入/ 规约/ 接受/ 报错

	- 使用栈的原因

		- 句柄总是出现在栈的顶端而非中间

	- 冲突

		> 上下文无关文法不能使用移入、规约分析技术，因为即使知道接下来的k个输入符号，仍然无法判断移入、规约操作，技术上称为非LR文法

		- 二义性文法不可能是LR的 -> 不能确定是否是句柄

#### 2. LR技术

> 对输入从左到右的扫描，反向构造出一个最右推导序列，向前看k个输入符号

- 优缺点

	- 优点 ---- 为什么用LR
		- 表格驱动的分析器
		- 只要能够写出该构造的上下文无关文法，就能构造出识别该程序设计语言的语法分析器
		- 无回溯的移入-规约方法的高效性
		- 尽可能早的检查错误
		- 相比LL可以描述更多的语言
	- 缺点
		- 手工构造分析器工作量大

- 项和LR(0)自动机

	- 项

		> 一些状态的集合使分析器知道何时移入、规约

		- 产生式加上一个位于它的体中某处的点
		- 可表示为：基础文法的产生式编号 + 点的位置 -> 两个整数
		- 项指明了在语法分析过程的给定点上，我们已经看到了一个产生式的哪些部分

	- LR(0)自动机

		<a>https://blog.csdn.net/Johan_Joe_King/article/details/79051993</a>

		- 规范LR(0)项族集

		  > 提供了一个构建确定的有限状态机的基础，可用于语法分析决定

		  - 增广文法

		  	> 若G以S开头，则加入新开始符号S‘，和产生式S’ -> S

		  	- 目的：告诉语法分析器何时应该停止语法分析并接受符号串

		  - CLOSURE

		  	- 构造方法：I 是文法G的一个项集，根据一下两个规则构造项集的闭包

		  		- 将I的各个项加入CLOSURE(I)中

		  		- 如果A->α.Bβ在Closure(I)中，并且项B->.γ不在Closure(I)中，则加入这个项。不断应用该规则直到没有新项产生为止

		  	- 分类
		
		  		- 内核项：包括初始项S’ -> S以及点不在最左端的所有项
		  		- 非内核项：除了初始项S’ -> S以及点在最左端的所有项

		  - GOTO(I, X)
		
		  	- 定义：项集I中所有形如[A->α.Xβ]的项所对应的项[A->αX.β]的集合的闭包（closure）
		  	- 描述了当输入为X离开状态I的转换

		- 规范集族的算法
		
		  - 开始状态为CLOUSURE({[S' -> .S]})
		  - 假设文法符号串γ使自动机从开始状态0运行到某个状态j，如果下一个输入字符为a且状态j上有一个在a的转换，就移入a
		
		- LR语法分析算法
		
			- 组成：输入+输出+栈+驱动程序+语法分析表（Action + GOTO）
			- ACTION函数：状态i + 终结符号a
			- 格局：分析器的完整状态包括栈和雨下的输入
		
		- 分析器实际行为
		
			- 若Action移入s，语法分析器执行移入操作，将下一个状态s移入栈中
			- 若规约，则将r个状态符号弹出栈，输入符号不变
			- 若Action接受，语法分析过程完成
			- 若Action报错，语法分析器发现语法错误，调用错误恢复例程
		
		![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/lr.png)

## 三. 语义分析

> 使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，同时也收集类型信息

