---
title: 'FiFi‘s School Work: Compilers'
date: 2022-05-02
permalink: /posts/2022/05/blog-post-compilers/
tags:
  - CS
  - Knowledge
---

重庆大学计算机学院 ｜ 22Spring ｜ 编译原理

## 一. 词法分析

## 二. 语法分析

> 语法分析器使用词法分析器中生成的各个词法单元的第一个分量来创建树形的中间表示，利用其（多为语法树）给出词法单元流的语法结构

#### 语法树

每个内部节点代表一个运算，节点的子节点表示该运算的分量



### Ⅰ 相关概念

- 句型：S 推倒出 α，而S是文法G的开始符号，则α是G的句型
- 句子：不包含非终结符号的句型
- 语言：文法生成的所有句子的集合
- 上下文无关语言：可以由文法生成的语言
- 等价文法：两个文法生成相同的语言

### Ⅱ 上下文无关文法

> 文法描述了大多数程序设计语言构造的层次化语法模型。
>
> 一个上下文无关文法由：一个终结符号集合（小写字母，运算符，标点符，数字，黑体字符串）、一个非终结符号集合（大写字母，小写、斜体的名字，字母表排在后面的小写字母，小写的希腊字母）、一个产生式集合和一个指定的非终结符号为开始符号组成。

#### 1. 二义性

> 一个文法可以为某个句子生成多棵语法分析树 <--> 对同一个句子有多个最左推导或最右推导的文法

#### 2. 两种推导过程

- 最左推导 Leftmost Deviation
	- 总是选择每个句型的最左非终结符号，写作$lm$
- 最右推导 Rightmost Deviation（规范推导）
	- 总是选择最右边的非终结符号，写作$rm$

#### 3. 语法分析树的常用构造方法

- 自顶向下的
	- 从语法树的顶部（根结点）开始向底部（叶子结点）构造语法分析树
	- 不能应用于带左递归文法的语法分析
- 自底向上的
	- 从叶子结点开始向根结点方向扫描构造语法分析树
	- “最右”推导

### Ⅲ 设计文法

#### 1. 二义性的消除

- 中间的语句不能以一个尚未匹配的语句结尾 P134

#### 2. 左递归的消除

> 如果一个文法中有一个非终结符号A使得对某个串å存在一个推导：A -> Aα，则称这个文法有左递归

- 如何替换

	- 直接左递归
		$$
		A -> Aα | ß    \   替换为：   A -> ßA'     ;\         A' -> αA' | ε
		$$

	- 间接左递归

		方法类似

	- 无环左递归

		![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/GsyxIK.png)

#### 3. 左公因子的提取

> 一种文法转换方法，可以适用于预测分析技术或自顶向下分析技术的文法

- 对于产生式
	$$
	 A -> αβ_1 | αβ_2 | η 
	$$
	
- $$
	A -> αA | η';\ Α' -> β_1|β_2
	$$

	

#### 4. 非上下文无关语言的构造

> C、Java这种语言是非上下文无关的，因为都要求标识符先声明后使用，在这些语言的编译器中，标识符是否先声明后使用是在语义分析阶段检查的

### Ⅳ 自顶向下的语法分析

> 可以被看成为输入串构造语法分析树的问题：从根结点开始按照深度优先的场景语法分析树的各个节点（寻找最左推导过程）
>
> 🏆关键：确定对一个非终结符号应用哪一个产生式

#### 1. 递归下降的语法分析

> 由一组过程组成，每个非终结符号有一个对应的过程，程序的执行从开始符号对应的过程开始，如果这个过程的过程体扫描了整个输入串，他就停止并宣布语法分析完成

- 通用的递归下降分析可能需要回溯：最初选择产生式的时候不确定
- 左递归的文法会使递归下降的语法分析器进入一个无限循环♾️

#### 2. First 和 Follow

> First(α) ：可从**α推导得到的串的首符号集合**，其中α是任意的文法符号串，该集合中可包含ε
>
> Follow(A)：对于非终结符号A，该集合被定义为可能在**某些句型中紧跟在A右边的终结符号的集合**，可包括$（结束标记）

- 计算**各个文法符号X的First(X)规则**：不断应用该规则，直至没有新的终结符号或ε可以被加入到任何的First集合中为止

	- 如果X是一个终结符号，那么First(X) = X
	- 如果X是一个非终结符号，且$X -> Y_1Y_2...Y_k$是一个产生式，k≥1，那么对于某个i，a在Firtst($Y_i$)中且ε在所有的First($Y_1$), First($Y_2$), ..., First($Y_(i-1)$)中，那么就把a加入First(X)
	- 如果$X->ε$是一个产生式，那么将ε加入到First(X)中

- 计算**串$X_1X_2...X_k$的First(X)规则**：

	- 加入F($X_1$)的所有非ε符号，若ε在F($X_1$)中，则加入F($X_2$)的所有非ε符号，以此类推，若所有的i，ε都在First($X_i$)中，则加入ε

- 计算所有**非终结符号A的Follow(A)集合的规则**：不断应用该规则，直到没有新的终结符号可以被加入到任意Follow集合中为止

	> 🥹 注意记录Follow(x) 是在哪个Follow(y)里，这样循环的时候好发现

	- 将$（输入右端的结束标记） 放到Follow(S)中，其中S是开始符号
	- 如果存在一个产生式$A->αBβ$，那么First(β)中出了ε之外的所有符号都在Follow(B)中
	- 如果存在一个产生式$A->αB$，或$A->αBβ$，且First(β)包含ε，那么Follow(A)中的所有符号都在Follow(B)中

#### 3. LL(1)文法

> 可以通过该文法构造出预测分析器（无需回溯的递归下降语法分析器）
>
> 第一个“L”表示从左向右扫描输入，第二个“L”表示产生最左推导，“1”表示在每一步中只需要向前看一个输入符号来决定语法分析的动作
>
> 该文法足以描述大部分程序设计语言构造，但注意⚠️：左递归的文法和二义性的文法都不可能是LL(1)的

- **判断文法G是否为LL(1)的**，当且仅当G的任意两个产生式$A->α | β$满足下面的条件：
	- ① FIRST(α)和FIRST(β)是不相交的集合
		- 不存在终结符号a使得α和β都能够推导出以a开头的串
		- α和β中最多只有一个可以推导出空串
	- ② 如果ε在FIRST(β)中，那么 FIRST(α)和FOLLOW(A)是不想交的集合；在FIRST(α)中亦然
		- β能推出空，那么α不能推导出任何以Follow(A)中某个终结符号开头的串；α亦然

- 构建**预测分析表**的算法

	> ⚠️注意：细节如：｜的处理
	>
	> 如果该文法存在左递归或者二义性，那么分析表M至少会包含一个多重定义的条目

	- 对于文法G的每个产生式 $A->α$，进行如下处理：
		- 对于FIRST(α)中的每个终结符号a，将$A->α$ 加入M[A,a]中
		- 如果ε在FIRST(α)中，那么对于FOLLOW(A)中的每个终结符号b，将$A->α$加入到M[A,b]中。如果ε在FIRST(α)中，且\$在FOLLOW(A)中，也将$A->α$加入到M[A,$]中
		- 完成以上操作后，如果M[A,a]中没有产生式，则将其设置为error（或空条目）

#### 4. 非递归的预测分析

> [非递归](https://so.csdn.net/so/search?q=非递归&spm=1001.2101.3001.7020)的预测分析**不需要**为每个非终结符**编写递归下降过 程**，而是根据预测分析表构造一个**自动机**，也叫**表驱动的预测分析。**即增加一个栈，来**增强自动机的识别能力**

- 表驱动的预测语法分析

	https://www.bilibili.com/video/BV1zW411t7YE?p=24

	![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/ll1.png)

#### 5. 预测分析的错误恢复

- 错误恢复策略
	- 恐慌模式
	
		恐慌模式的恢复：语法分析器一旦发现错误就不断丢弃输入中的符号，知道找到同步词法单元集合中的某个元素
	
		- 同步集合的选取：
			- 将Follow(A)中的所有符号放到非终结符号A的同步集合中
			- 把较高层构造的开始符号加入到较低层构造的同步集合中去
			- 把First(A)中的符号加入到非终结符号A的同步集合中去
			- ... P146
	
	- 短语层次恢复
	
		短语层次的恢复：在余下的输入上进行局部性纠正
	
	- 其他
	
		- 错误产生式
	
		- 全局纠正
	

### Ⅴ 自底向上的语法分析

> 对应为一个输入串构造语法分析树的过程，从叶子结点逐渐向上到达根结点，构造过程较为方便
>
> 目的😄：反向构造一个推导过程（最右推导）

#### 1. 移入、规约语法分析技术

- 规约

> 将自底向上语法分析过程看成将一个串w规约为文法开始符号的过程，在规约的步骤中，一个与某产生式体相配的特定子串被替换为该产生式头部的非终结符号

- 短语、句子、句柄

> 相关概念✈️：https://blog.csdn.net/qq_43543789/article/details/104818368
>
> 短语：语法树中任一子树叶结点所组成的符号串
>
> 直接短语：子树中不再包含其他的子树
>
> 句柄 handle：**直接短语中的最左直接短语为该句型的句柄**（若为二义性文法，则可能存在不止一个最右推导，不止一个句柄）
>
> 句柄是和某个产生式体相匹配的子串，子串中既可能包括终结符号，也可能包括非终结符号。⚠️ 如果其中包括非终结符号，那么字符串必然经过了一次或多次归约。

- 移入、规约语法分析技术 -- 简单LR技术

	- 自底向上语法分析的一种形式

	- 方法

		- 栈保存文法符号，输入缓冲区存放将要语法分析的剩余符号
		- 对输入栈的从左到右扫描过程中，语法分析器将0个或多个输入符号移到栈的顶端，知道可以对栈顶的一个文法符号串β进行规约（替换成产生式头部的非终结符）为止
		- 将β规约为某个产生式的头
		- 循环知道检测到语法错误或者栈中包括开始符号且输入缓冲区为空为止

	- 可能的动作

		- 移入/ 规约/ 接受/ 报错

	- 使用栈的原因

		- 句柄总是出现在栈的顶端而非中间

	- 冲突

		> 上下文无关文法不能使用移入、规约分析技术，因为即使知道接下来的k个输入符号，仍然无法判断移入、规约操作，技术上称为非LR文法

		- 二义性文法不可能是LR的 -> 不能确定是否是句柄

#### 2. LR技术

> 对输入从左到右的扫描，反向构造出一个最右推导序列，向前看k个输入符号

- 优缺点

  - 优点 ---- 为什么用LR
  	- 表格驱动的分析器
  	- 只要能够写出该构造的上下文无关文法，就能构造出识别该程序设计语言的语法分析器
  	- 无回溯的移入-规约方法的高效性
  	- 尽可能早的检查错误
  	- 相比LL可以描述更多的语言
  - 缺点
  	- 手工构造分析器工作量大

- 项和LR(0)自动机

  - 项

    > 一些状态的集合使分析器知道何时移入、规约

    - 产生式加上一个位于它的体中某处的点
    - 可表示为：基础文法的产生式编号 + 点的位置 -> 两个整数
    - 项指明了在语法分析过程的给定点上，我们已经看到了一个产生式的哪些部分

  - LR(0)自动机

    > 和LL(1)的区别：栈里存放的是状态，而不是文法符号。
    >
    > 引入状态从而表示文法符号所处的具体位置，因此，一个文法符号可以对应多个状态。

    <a>https://blog.csdn.net/Johan_Joe_King/article/details/79051993</a>

    - 规范LR(0)项族集

      > 提供了一个构建确定的有限状态机的基础，可用于语法分析决定

      - 增广文法

      	> 若G以S开头，则加入新开始符号S‘，和产生式S’ -> S

      	- 目的：告诉语法分析器何时应该停止语法分析并接受符号串

      - CLOSURE

      	- 构造方法：I 是文法G的一个项集，根据一下两个规则构造项集的闭包

      		- 将I的各个项加入CLOSURE(I)中

      		- 如果A->α.Bβ在Closure(I)中，并且项B->.γ不在Closure(I)中，则加入这个项。不断应用该规则直到没有新项产生为止

      	- 分类

      		- 内核项：包括初始项S’ -> S以及点不在最左端的所有项
      		- 非内核项：除了初始项S’ -> S以及点在最左端的所有项

      - GOTO(I, X)

      	- 定义：项集I中所有形如[A->α.Xβ]的项所对应的项[A->αX.β]的集合的闭包（closure）
      	- 描述了当输入为X离开状态I的转换

    - 规范集族的算法

      - 开始状态为CLOUSURE({[S' -> .S]})
      - 假设文法符号串γ使自动机从开始状态0运行到某个状态j，如果下一个输入字符为a且状态j上有一个在a的转换，就移入a

    - LR语法分析算法

      - 组成：输入+输出+栈+驱动程序+语法分析表（Action + GOTO）

      ![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/structure.png)

      - 状态转换表Goto[i, X] : 决定目前状态 i 碰到文法符号 X 时该跳转到的目标状态
      - 动作表Action[i, a] : 决定目前状态 i 碰到输入符号 a 时采取的动作。三种可能的动作为：
      	- shift n(记为sn): 将状态n压进栈 (相当于移入符号a)
      	- reduce m(记为rm):使用第m条文法规则归约栈顶的内容
      	- accept(记为acc): 接受
      - 格局：分析器的完整状态包括栈和余下的输入

    - 语法分析表

    	![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/analyzeTable.png)

    - 分析器实际行为

      ![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/working.png)

      - 若Action移入s，语法分析器执行移入操作，将下一个状态s移入栈中
      - 若规约，则将r个状态符号弹出栈，输入符号不变
      - 若Action接受，语法分析过程完成
      - 若Action报错，语法分析器发现语法错误，调用错误恢复例程

    ![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/lr.png)

- SLR语法分析表

	> 为了解决移入、规约冲突

	![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/slr.png)

	- 可行前缀

		> 是一个最右句型的前缀，并且她没有越过该最右句型的最右句柄的右端

		SLR可以识别可行前缀

- LR(1)

	> 移进项和规约项若相交不为空，不能使用SLR分析，使用LR(1)解决
	>
	> 通过分裂状态，使LR分析器的每个状态能确切知道句柄a后紧跟哪些终结符时才能把a归约成A

	- 类型区别

	  ![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/types.png)

	- 分析表的构造

	  - 有效项

	  	![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/lr1.png)

	  	![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/lr2.png)

	  	![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/exp.png)

	  	![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/point.png)

	- 项集族的构造方法

	  ![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/lr1Algo.png)
	
	- LR(1)分析表
	
	  > 区别在于规则2：
	  >
	  > LR(0)分析表：若项集Ik包含归约项A→a.，对于所有a∈VT，则置ACTION[k,a]= rj，表示用第j个产生式进行归约。
	  >
	  > SLR(1)分析表：若项集Ik包含归约项A→a.，对于a∈FOLLOW(A)，则置ACTION[k,a]= rj，意为用第j个产生式进行归约。
	
	  ![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/at.png)
	
	- LR(1)分析器
	
	  > 缺点：需要比SLR(1)多很多的状态
	
	- LALR(1)
	
		> LALR(1)分析器通过合并LR(1)中具有相同核心的项集，从而大大地减少了状态数
		>
		> 在所有的LR方法中，LALR比SLR强，比LR(1)弱。综合功能和效率，LALR(1)分析器通常是最佳的选择
	
	- LR 和 LL的比较
	
		> LL(1)根据FIRST(ai)确定使用哪条产生式；而LR(k)是在识别出整个a后,再往后看k个符号,然后确定使用哪条产生式。
		>
		> LL(1)文法都是LR(1)文法；都能用形式化方法实现
	


## 三. 语义分析

> 使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，同时也收集类型信息

### Ⅰ 语法制导翻译

> 语言的形式：语法表述
>
> 程序本身的含义：语义
>
> 语法制导翻译 -> 如何在语法上绑定语义，是最常用的语义分析技术，具体包括两种标记方法

#### 1. 语法制导定义 Syntax Directed Definition

- 基本思想：

	- 在上下文无关文法的基础上，将语言结构的语义以**属性**的形式赋予代表此结构的文法符号。
	- 属性的计算以**语义规则**的形式赋予由文法符号组成的产生式

- 语义规则：用来计算与产生式中出现的文法符号相关联的属性的值。在语法制导定义中，任意一条产生式都有与之关联的一套语义规则（当归约或推导到某个产生式时，除了按照产生式进行相应的代换之外(语法分析)，还要按照所对应的语义规则执行操作， 如计算表达式、查填符号表、产生中间代码。）

- 语法树结点N上非终结符号A的属性

	- 综合属性：只能通过N的子结点或者只依赖于N本身的属性值来定义
	- 继承属性：只能通过N的父节点、N本身和兄弟结点上的属性值来定义

- 求值顺序

	> 对于同时具有继承、综合属性的SDD，不能保证有一个顺序来对所有节点上的属性进行求值

	- 依赖图：每个属性为结点，属性a到b的有向边表示计算b时需要a的值（若SDD对应的依赖图中不存在环，则至少存在一个顺序求取所有属性的值）

- S-属性的语法制导定义：只用综合属性的SDD

	> 结点属性值的计算正好和自底向上分析建立分析树结点同步进行，通常使用自底向上的语法分析，对产生式规约后，就执行产生式对应的语义规则计算属性的值

- L-属性的语法制导定义

	> 每个s-属性定义都是l-属性定义

	- 每个属性要么是综合属性，要么是继承属性且满足以下要求：假设存在产生式A→X1X2…Xn, 且通过这产生式所关联的语义规则可计算得到继承属性Xi.a,那么这个规则只能使用：
		- 和产生式头A关联的继承属性
		- 位于Xi左边的文法符号相关的X1,X2，…Xi-1继承属性或综合属性
		- Xi本身的继承属性或综合属性，且Xi的全部属性组成的依赖图中不存在环。

#### 3. 语法制导的翻译方案

> 🤓 一种上下文无关文法，语义动作程序段被嵌入到产生式右部，语义动作可以出现在产生式中的任何位置，该位置决定动作的执行顺序
>
> 🤓 类似语法制导定义，只是动作的计算顺序是显示给出的
>
> 😎 一种语法分析和语义动作交错的表示法，表达在按深度优先遍历分析树的过程中何时执行语义动作

任何SDT都可按如下方式实现：首先建立一颗语法分析树，然后按照从左到右的深度优先顺序来执行这些动作，即对树的先序遍历

- 后缀翻译方案及实现

	> 最简单的实现SDD的情况：文法可以用自底向上方法来分析且该SDD是S属性的。
	>
	> 这时，我们可构造出一个SDT，每个语义动作放在产生式的最右，并在该产生式归约时执行这个动作。

- L属性定义的SDT

	> SDD -> SDT规则：
	>
	> 1️⃣ 将计算一个产生式头的综合属性的动作放置在这个产生式体的最右端。
	>
	> 2️⃣ 把计算某个非终结符号A的继承属性的动作插入到产生式体中紧靠在A的本次出现之前的位置上。

![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/sdt.png)

#### 4. 从翻译方案中消除左递归

> 对于一个翻译方案，若采用自顶向下分析，必须消除左递归和提取左公因子，在改写基本文法时考虑属性值的计算

![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/eg.png)

!![img](https://raw.githubusercontent.com/FionaChan01/FionaChan01.github.io/master/post_image/post_compiler/eg2.png)
